[toc]



```java
class Solution {
    public boolean canPartitionKSubsets(int[] nums, int k) {
        if (nums == null || nums.length == 0) return false;

        // 检查和是否可分
        int sum = 0;
        for (int num : nums) sum += num;

        if (sum % k != 0) return false;

        sum /= k;

        return canPartitionKSubsets(new int[k], nums, 0, sum);
    }

    private boolean canPartitionKSubsets(int[] bucket, int[] nums, int start, int target) {
        // 所有数字分配完，有效
        if (start >= nums.length) return true;
        int num = nums[start++];
        // 将start位置的数分配到k个桶中
        for (int i = 0; i < bucket.length; i++) {
            if (bucket[i] + num > target) continue;
            bucket[i] += num;
            if (canPartitionKSubsets(bucket, nums, start, target)) return true;
            bucket[i] -= num;
        }
        return false;
    }
}
```





```java
class Solution {
    public boolean canPartitionKSubsets(int[] nums, int k) {
        if (nums == null || nums.length == 0) return false;

        // 检查和是否可分
        int sum = 0;
        for (int num : nums) sum += num;

        if (sum % k != 0) return false;

        sum /= k;

        // 排序判断
        Arrays.sort(nums);
        int start = nums.length - 1;
        if (nums[start] > sum) return false;
        while (start >= 0 && nums[start] == sum) {
            start--;
            k--;
        }

        return canPartitionKSubsets(new int[k], nums, start, sum);
    }

    private boolean canPartitionKSubsets(int[] bucket, int[] nums, int start, int target) {
        // 所有数字分配完，有效
        if (start < 0) return true;
        int num = nums[start--];
        // 将start位置的数分配到k个桶中
        for (int i = 0; i < bucket.length; i++) {
            if (bucket[i] + num > target) continue;
            bucket[i] += num;
            if (canPartitionKSubsets(bucket, nums, start, target)) return true;
            bucket[i] -= num;
        }
        return false;
    }
}
```

