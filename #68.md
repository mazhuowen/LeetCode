[toc]

```java
class Solution {
    public List<String> fullJustify(String[] words, int maxWidth) {
        List<String> res = new LinkedList<>();
        if (words == null || words.length == 0) return res;

        int idx = 0, curLen = 0;
        List<String> row = new LinkedList<>();
        while (idx < words.length) {
            // 句中加入单词及句首加入单词
            if (curLen + words[idx].length() + 1 <= maxWidth || (curLen == 0 && words[idx].length() <= maxWidth)) {
                curLen += words[idx].length() + (curLen == 0 ? 0 : 1);
                row.add(words[idx]);
            }
            // 换行
            else {
                res.add(formatRow(row, maxWidth, false));
                curLen = words[idx].length();
                row = new LinkedList<>();
                row.add(words[idx]);
            }
            idx++;
        }
        res.add(formatRow(row, maxWidth, true));
        return  res;
    }

    private String formatRow(List<String> sents, int maxWidth, boolean isLast) {
        StringBuffer sb = new StringBuffer();
        if (isLast) {
            // 单词间拼接空格
            for (String token : sents) sb.append(token).append(" ");
            // 补充空格
            while (sb.length() < maxWidth) sb.append(" ");
            // 规范长度
            sb.setLength(maxWidth);
        } else {
            int len = maxWidth;
            int count = 0;
            for (String token : sents) {
                len -= token.length();
                count += 1;
            }

            // 剩余的len个空格需要分配到count - 1个地方
            for (String token : sents) {
                sb.append(token);
                // 最后一个单词无需拼接空格
                if (count == 1) break;
                // 计算当前空格长度
                int curLen = len / (count - 1) + (len % (count - 1) == 0 ? 0 : 1);
                len -= curLen;
                count--;
                for (int i = 0; i < curLen; i++) {
                    sb.append(" ");
                }
            }
            // 对应这一行只有一个单词的情况，必须左对齐，补全后侧
            while (sb.length() < maxWidth) sb.append(" ");
        }

        return sb.toString();
    }
}
```
