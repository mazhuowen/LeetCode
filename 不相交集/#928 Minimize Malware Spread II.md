[toc]

(This problem is the same as Minimize Malware Spread, with the differences bolded.)

In a network of nodes, each node `i` is directly connected to another node `j` if and only if `graph[i][j] = 1`.

Some nodes `initial` are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner.

Suppose `M(initial)` is the final number of nodes infected with malware in the entire network, after the spread of malware stops.

We will remove one node from the initial list, **completely removing it and any connections from this node to any other node**.  Return the node that if removed, would minimize `M(initial)`.  If multiple nodes could be removed to minimize `M(initial)`, return such a node with the smallest index.

Note:

* $1 < \text{graph.length} = \text{graph[0].length} \le 300$
* $0 \le \text{graph[i][j]} == \text{graph[j][i]} \le 1$
* $\text{graph[i][i]} = 1$
* $1 \le \text{initial.length} < \text{graph.length}$
* $0 \le \text{initial[i]} < \text{graph.length}$



## 题目解读

&emsp;与[#924 Minimize Malware Spread](./#924 Minimize Malware Spread.md)唯一的不同是，在本题中网络节点消除后，关于该结点的任何连接也会断开。

```java
class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {

    }
}
```

## 程序设计

* 和[#924 Minimize Malware Spread](./#924 Minimize Malware Spread.md)相比，只要一个局域网存在恶意结点，则整个局域网都会受到影响，这个不变；变的是移除一个结点，同时会断开其所有的连接，又由于边是有向的，势必会形成新的连通分量。
* 既然删除结点会使得该结点的任何连接断开，形成一个点，如果找到连通分量，每次还需要出去当前待移除点，然后判断移除当前点后分裂的连通分量和判断每个分量中的其它恶意结点，可以开始就移除所有恶意结点，得到连通分量后遍历恶意结点，记录连通分量连接到的恶意结点的数目。
* 显然如果一个集合能够连接到的多于两个恶意结点，则删除任意一个恶意结点都不会改变这个集合受到影响的数目。故删除恶意结点后，免受影响的的结点数目就是唯一能够连接到的恶意结点就是该恶意结点的集合尺寸之和。

```java
class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        // 映射结点是否是恶意结点
        boolean[] malwares = new boolean[n];
        for(int idx : initial) malwares[idx] = true;
        // 构造无恶意结点的连通分量
        DisJoint disJoint = new DisJoint(n);
        for(int i = 0; i < n; i++) {
            if(malwares[i]) continue;
            // 无向图只遍历上三角
            for(int j = i; j < n; j++) {
                if(malwares[j]) continue;
                // 连接且不是恶意结点，则加入不相交集
                if(graph[i][j] == 1) {
                    disJoint.union(disJoint.find(i), disJoint.find(j));
                }
            }
        }
        Map<Integer, Set<Integer>> connects = new HashMap<>();
        // 记录正常结点能连通到恶意结点的数量（只对根节点做记录，是本题关键）
        int[] record = new int[n];
        // 记录最小结点
        int minNode = n;
        // 对于每个恶意结点，判断与其连接的连通分量
        for(int u : initial) {
            minNode = Math.min(minNode, u);
            // 记录与当前结点连接的不相交集根节点
            Set<Integer> set = new HashSet<>();
            for(int v = 0; v < n; v++) {
                if(malwares[v]) continue;
                // 找到一条连接到正常结点的边，找到对应的根节点加入集合（由于是无向图只判断一个方向）
                if(graph[u][v] == 1) {
                    set.add(disJoint.find(v));
                }
            }
            // 集合连通到的恶意结点数目加一
            for(int root : set) {
                record[root]++;
            }
            // 将恶意结点和与他相连的连通分量一起放入字典
            connects.put(u, set);
        }
        // 移除恶意结点免受影响的最大结点数
        int max = 0;
        // 对应的恶意结点
        int node = n;
        for(Map.Entry<Integer, Set<Integer>> entry : connects.entrySet()) {
            // 移除当前恶意结点免受影响的最大结点数
            int cur = 0;
            for(int root : entry.getValue()) {
                // 如果集合只与当前这个恶意结点连接，删除后集合内都会免受影响
                if(record[root] == 1) {
                    cur += disJoint.getSetSize(root);
                }
            }
            // 记录最优结点
            if(max < cur) {
                node = entry.getKey();
                max = cur;
            } 
            // 数目一样则选取结点小的
            else if(max == cur) {
                node = Math.min(node, entry.getKey());
            }
        }
        // 恶意结点全部未与正常结点连通，导致上面的循环不走，选择最小的
        if(node == n) {
            return minNode;
        }
        return node;
    }
}

class DisJoint {
    private int size;
    private int[] tree;

    DisJoint(int size) {
        this.size = size;
        this.tree = new int[size];
        Arrays.fill(tree, -1);
    }

    public void union(int root1, int root2) {
        if(tree[root1] >= 0 || tree[root2] >= 0) throw new IllegalArgumentException("not a root");
        if(root1 == root2) return;

        if(tree[root1] <= tree[root2]) {
            tree[root1] += tree[root2];
            tree[root2] = root1;
        } else {
            tree[root2] += tree[root1];
            tree[root1] = root2;
        }
        size--;
    }

    public int find(int idx) {
        if(tree[idx] < 0) return idx;
        return tree[idx] = find(tree[idx]);
    }

    public int size() {
        return size;
    }

    public int getSetSize(int idx) {
        return -tree[find(idx)];
    }
}
```

## 性能分析

&emsp;时间复杂度为$O(N^2)$，空间复杂度为$O(KN)$，其中$K$是移除点数。

执行用时：6ms，在所有java提交中击败了100.00%的用户。

内存消耗：57.3MB，在所有java提交中击败了100.00%的用户。

## 官方解题

&emsp;除了不相交集思路，官方还提供了深度搜索思路，把不相交集获取连通集合使用深度优先搜索代替。