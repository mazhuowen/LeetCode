[toc]

```java
class Solution {

    public List<List<Integer>> verticalTraversal(TreeNode root) {
        LinkedList<List<Integer>> res = new LinkedList<>();
        if (root == null) return res;

        int offset = 0;
        Queue<Pair> queue = new LinkedList<>();
        queue.add(new Pair(root, 0));

        while (!queue.isEmpty()) {
            int size = queue.size();
            while (size > 0){
                // 当前层坐标
                int idx = queue.peek().idx;
                LinkedList<TreeNode> temp = new LinkedList<>();
                // 坐标相同
                while (size > 0 && queue.peek().idx == idx) {
                    size--;
                    temp.add(queue.poll().node);
                }
                // 对坐标相同的点进行排序，值小的在前面
                if (temp.size() > 1) temp.sort((a, b) -> a.val - b.val);
                // 依次加入链表
                if (idx + offset >= 0) {
                    if (idx + offset >= res.size() || res.get(idx + offset) == null)
                        res.addLast(new LinkedList<>());
                } else {
                    res.addFirst(new LinkedList<>());
                    offset++;
                }
                for (TreeNode cur : temp) res.get(idx + offset).add(cur.val);
                // 加入队列
                for (TreeNode cur : temp) if (cur.left != null) queue.add(new Pair(cur.left, idx - 1));
                for (TreeNode cur : temp) if (cur.right != null) queue.add(new Pair(cur.right, idx + 1));
            }
        }
        return res;
    }
}

class Pair {
    TreeNode node;
    int idx;

    public Pair(TreeNode node, int idx) {
        this.node = node;
        this.idx = idx;
    }
}
```
